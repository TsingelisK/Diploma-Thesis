# -*- coding: utf-8 -*-
"""Model

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AXuMqmFnO65Amazyjf5tQEaf1mSHS387
"""

import torch
from torch import nn
!pip install torch_geometric
from torch_geometric.nn import RGCNConv,FastRGCNConv,GCNConv,GATConv
import torch.nn.functional as F
import pickle
import numpy as np
from sklearn.metrics import f1_score,accuracy_score,precision_score,recall_score,matthews_corrcoef

class My_bot_detector(nn.Module):
    def __init__(self,dropout=0.3,des_emb=64,cluster_emb=64,des_size=768,tweet_size=768,num_emb=64,cat_emb=64,num_prop_size=5,cat_prop_size=3):
        super(My_bot_detector, self).__init__()
        self.dropout = dropout

        self.usr_des=nn.Sequential(
           nn.Linear(des_size,des_emb),
           nn.LeakyReLU())


        self.tweet_cluster0=nn.Sequential(
           nn.Linear(tweet_size,cluster_emb),
           nn.LeakyReLU())


        self.tweet_cluster1=nn.Sequential(
           nn.Linear(tweet_size,cluster_emb),
           nn.LeakyReLU())


        self.tweet_cluster2=nn.Sequential(
           nn.Linear(tweet_size,cluster_emb),
           nn.LeakyReLU())


        self.tweet_cluster3=nn.Sequential(
           nn.Linear(tweet_size,cluster_emb),
           nn.LeakyReLU())


        self.tweet_cluster4=nn.Sequential(
           nn.Linear(tweet_size,cluster_emb),
           nn.LeakyReLU())


        self.num_prop=nn.Sequential(
           nn.Linear(num_prop_size,num_emb),
           nn.LeakyReLU())



        self.cat_prop=nn.Sequential(
           nn.Linear(cat_prop_size,cat_emb),
           nn.LeakyReLU())


        embedding_dimension=cat_emb+num_emb+ (5*cluster_emb)+des_emb
        self.linear_relu_input=nn.Sequential(
           nn.Linear(embedding_dimension,embedding_dimension),
           nn.LeakyReLU())


        self.rgcn1=RGCNConv(embedding_dimension,embedding_dimension,num_relations=2)

        nn.init.xavier_uniform_(self.rgcn1.weight)

        self.rgcn2=RGCNConv(embedding_dimension,embedding_dimension,num_relations=2)

        nn.init.xavier_uniform_(self.rgcn2.weight)


        self.linear_relu_output1=nn.Sequential(
           nn.Linear(embedding_dimension,embedding_dimension),
           nn.LeakyReLU())


        self.linear_output2=nn.Linear(embedding_dimension,2)





    def forward(self,des,tweet0,tweet1,tweet2,tweet3,tweet4,num_properties,cat_properties,edge_index,edge_type):
        d=self.usr_des(des)

        t0=self.tweet_cluster0(tweet0)
        t1=self.tweet_cluster1(tweet1)
        t2=self.tweet_cluster2(tweet2)
        t3=self.tweet_cluster3(tweet3)
        t4=self.tweet_cluster4(tweet4)


        n=self.num_prop(num_properties)

        c=self.cat_prop(cat_properties)

        x=torch.cat((d,t0,t1,t2,t3,t4,n,c),dim=1)

        x=self.linear_relu_input(x)

        x=self.rgcn1(x,edge_index,edge_type)
        x=F.dropout(x,p=self.dropout,training=self.training)

        x=self.rgcn2(x,edge_index,edge_type)
        x=self.linear_relu_output1(x)
        x=self.linear_output2(x)

        return x